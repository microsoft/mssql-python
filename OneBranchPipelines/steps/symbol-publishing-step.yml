# Symbol Publishing Step Template
# Publishes PDB symbols to Azure DevOps Symbol Server and Microsoft Symbol Publishing Service
parameters:
  - name: SymbolsFolder
    type: string
    default: '$(ob_outputDirectory)\symbols'

steps:
  # Set AccountName for SqlClientDrivers organization (separate PowerShell task like JDBC)
  - task: PowerShell@2
    displayName: 'Set Symbol.AccountName to SqlClientDrivers'
    inputs:
      targetType: inline
      # NOTE: we're setting PAT in this step since Pat:$(System.AccessToken) doesn't work in PublishSymbols@2 task directly
      # Tried using env: parameter on PublishSymbols@2 but it didn't work
      # This is a workaround to set it via script, and setting as a secret variable
      script: |
        Write-Host "##vso[task.setvariable variable=ArtifactServices.Symbol.AccountName;]SqlClientDrivers"
        Write-Host "##vso[task.setvariable variable=ArtifactServices.Symbol.Pat;issecret=true;]$env:SYSTEM_ACCESSTOKEN"
        # Verify System.AccessToken is available
        if (-not $env:SYSTEM_ACCESSTOKEN) {
          Write-Error "SYSTEM_ACCESSTOKEN is not available. Ensure 'Allow scripts to access the OAuth token' is enabled in the pipeline settings."
        } else {
          Write-Host "SYSTEM_ACCESSTOKEN is available and will be used for symbol publishing."
        }
    env:
      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
  
  - task: PublishSymbols@2
    displayName: 'Push Symbols to SqlClientDrivers ADO Organization'
    inputs:
      SymbolsFolder: '${{ parameters.SymbolsFolder }}'
      SearchPattern: '**/*.pdb'
      IndexSources: false
      SymbolServerType: TeamServices
      SymbolsMaximumWaitTime: 10
      SymbolsProduct: mssql-python
      SymbolsVersion: $(Build.BuildId)
  
  # Publish to Microsoft Symbol Publishing Service (External)
  # This step finds the request name created by PublishSymbols@2 task above and publishes to internal/public servers
  # The PublishSymbols@2 task uploads symbols and creates a request; this step marks it for publishing
  # 
  # PREREQUISITES (Critical for avoiding 403 Forbidden errors):
  # 1. Project must be registered with Symbol team via IcM incident (ICM 696470276 for mssql-python)
  # 2. Service principal/identity used by azureSubscription must be added as Reader AND Publisher
  #    - Symbol team must explicitly grant this identity access to your project
  #    - 403 errors indicate the identity hasn't been added or wrong identity is being used
  # 3. Verify identity matches: az account get-access-token will use the identity from azureSubscription
  # 
  # Reference: https://www.osgwiki.com/wiki/Symbols_Publishing_Pipeline_to_SymWeb_and_MSDL#Step_3:_Project_Setup
  - task: AzureCLI@2
    displayName: 'Publish symbols to Microsoft Symbol Publishing Service'
    condition: succeeded()
    env:
      SymbolServer: '$(SymbolServer)'
      SymbolTokenUri: '$(SymbolTokenUri)'
    inputs:
      azureSubscription: 'SymbolsPublishing-msodbcsql-mssql-python'
      scriptType: ps
      scriptLocation: inlineScript
      inlineScript: |
        $symbolServer = $env:SymbolServer
        $tokenUri = $env:SymbolTokenUri
        $projectName = "mssql-python"

        # Get the access token for the symbol publishing service
        # This uses the identity from azureSubscription
        # CRITICAL: The identity must be registered as Reader AND Publisher for the project
        # Otherwise you'll get 403 Forbidden errors when calling the Symbol Publishing Service API
        $symbolPublishingToken = az account get-access-token --resource $tokenUri --query accessToken -o tsv
        echo ">  1.Symbol publishing token acquired."

        # CRITICAL: We search build logs to find the auto-generated request name from PublishSymbols@2
        # Two implementation patterns exist:
        # 1. JDBC Pattern (used here): PublishSymbols@2 auto-generates request name → search logs → publish
        # 2. SqlClient Pattern: Pass explicit symbolsArtifactName parameter → use same name → publish
        # We use JDBC pattern because it's more flexible and doesn't require parameter coordination
        
        # KEY LEARNING: Must use $(System.CollectionUri) for correct API URL construction
        # $(System.CollectionUri) = full org URL like "https://dev.azure.com/SqlClientDrivers/"
        # $(System.TeamProject) = only project name like "mssql-python"
        # Previous error: Used "https://dev.azure.com/$(System.TeamProject)" which resolved to
        # "https://dev.azure.com/mssql-python" (missing organization) → 404 error
        echo "Searching for request name created by PublishSymbols@2 task..."
        $logList = Invoke-RestMethod -Uri "$(System.CollectionUri)$(System.TeamProject)/_apis/build/builds/$(Build.BuildId)/logs?api-version=7.1" -Method GET -Headers @{ Authorization = "Bearer $(System.AccessToken)" } -ContentType "application/json"

        # KEY LEARNING: Build API returns logs in the .value property, not .logs
        # Previous error: Used $logList.logs → property not found
        # Azure DevOps Build API schema: { "value": [ { "id": 1, ... }, ... ] }
        $requestName = $null
        $logList.value | ForEach-Object {
            $id = $_.id
            $log = Invoke-RestMethod -Uri "$(System.CollectionUri)$(System.TeamProject)/_apis/build/builds/$(Build.BuildId)/logs/$id" -Method GET -Headers @{ Authorization = "Bearer $(System.AccessToken)" } -ContentType "application/json"
            
            echo $log > log.txt
            # PublishSymbols@2 creates a request with pattern like: Request 'mssql-python/{branch}/{date}.{build}/{buildId}/{guid}'
            # Example: Request 'mssql-python/official-release/25290.7-release/127537/23bc7689-7bae-4d13-8772-ae70c50b72df'
            $request = Select-String -Path log.txt -Pattern "Request '.*'" -ErrorAction SilentlyContinue
            
            if ($request -and $request -match "'mssql-python\/.*'") {
                $requestName = (-Split $Matches[0])[0].Replace("'","")
                echo "Found request name: $requestName"
            }
        }

        if (-not $requestName) {
            echo "##[error]Could not find request name in build logs. The PublishSymbols@2 task may have failed or not created a request."
            exit 1
        }

        echo ">  2.Request name found from PublishSymbols@2 task."

        # Register the request name with Symbol Publishing Service
        # This is an idempotent operation - if already registered, API returns success
        # KEY LEARNING: Use ConvertTo-Json for proper JSON formatting (not manual string construction)
        # This ensures correct boolean values and escaping
        echo "Registering the request name ..."
        $requestNameRegistration = @{ requestName = $requestName }
        $requestNameRegistrationBody = $requestNameRegistration | ConvertTo-Json -Compress
        try {
            Invoke-RestMethod -Method POST -Uri "https://$symbolServer.trafficmanager.net/projects/$projectName/requests" -Headers @{ Authorization = "Bearer $symbolPublishingToken" } -ContentType "application/json" -Body $requestNameRegistrationBody
            echo ">  3.Registration of request name succeeded."
        } catch {
            echo "Registration may have already existed (this is okay): $($_.Exception.Message)"
        }

        # Publish the symbols to internal and public servers
        # KEY LEARNING: This API call is asynchronous - it submits the request but doesn't wait for completion
        # We need to poll the status endpoint (below) to confirm when publishing finishes
        # Status codes: 0=NotRequested, 1=Submitted, 2=Processing, 3=Completed
        # Result codes: 0=Pending, 1=Succeeded, 2=Failed, 3=Cancelled
        echo "Publishing the symbols to internal and public servers..."
        $publishSymbols = @{
            publishToInternalServer = $true
            publishToPublicServer = $true
        }
        $publishSymbolsBody = $publishSymbols | ConvertTo-Json -Compress
        echo "Publishing symbols request body: $publishSymbolsBody"
        
        try {
            $response = Invoke-RestMethod -Method POST -Uri "https://$symbolServer.trafficmanager.net/projects/$projectName/requests/$requestName" -Headers @{ Authorization = "Bearer $symbolPublishingToken" } -ContentType "application/json" -Body $publishSymbolsBody
            echo ">  4.Request to publish symbols succeeded."
            echo "Response: $($response | ConvertTo-Json)"
        } catch {
            echo "##[error]Failed to publish symbols. Status Code: $($_.Exception.Response.StatusCode.value__)"
            echo "##[error]Error Message: $($_.Exception.Message)"
            if ($_.ErrorDetails.Message) {
                echo "##[error]Error Details: $($_.ErrorDetails.Message)"
            }
            throw
        }

        echo ">  3.Request to publish symbols succeeded."

        # Poll for publishing status until complete or timeout
        # KEY LEARNING: Publishing is asynchronous - need to poll until Status=3 (Completed)
        # Both internal and public servers must complete before we can confirm success
        # Timeout after 5 minutes (30 attempts × 10 seconds) as a safety measure
        echo ">  4.Checking the status of the request ..."
        $maxAttempts = 30  # 30 attempts = ~5 minutes with 10 second intervals
        $attemptCount = 0
        $publishingComplete = $false

        while (-not $publishingComplete -and $attemptCount -lt $maxAttempts) {
            $attemptCount++
            $status = Invoke-RestMethod -Method GET -Uri "https://$symbolServer.trafficmanager.net/projects/$projectName/requests/$requestName" -Headers @{ Authorization = "Bearer $symbolPublishingToken" } -ContentType "application/json"
            
            echo "Attempt $attemptCount/$maxAttempts - Status Check:"
            echo "  Internal Server: Status=$($status.publishToInternalServerStatus), Result=$($status.publishToInternalServerResult)"
            echo "  Public Server: Status=$($status.publishToPublicServerStatus), Result=$($status.publishToPublicServerResult)"
            
            # Wait for both servers to reach Status=3 (Completed)
            # KEY LEARNING: Empty file arrays (filesBlockedFromPublicServer, filesPublishedAsPrivateSymbolsToPublicServer)
            # are normal and expected - they populate only when there are blocked/private files
            $internalDone = $status.publishToInternalServerStatus -eq 3
            $publicDone = $status.publishToPublicServerStatus -eq 3
            
            if ($internalDone -and $publicDone) {
                $publishingComplete = $true
                echo ""
                echo "Publishing completed!"
                echo "  Internal Result: $($status.publishToInternalServerResult) (1=Success, 2=Failed)"
                echo "  Public Result: $($status.publishToPublicServerResult) (1=Success, 2=Failed)"
                
                # Check for failures and report with detailed messages
                if ($status.publishToInternalServerResult -eq 2) {
                    echo "##[warning]Internal server publishing failed: $($status.publishToInternalServerFailureMessage)"
                }
                if ($status.publishToPublicServerResult -eq 2) {
                    echo "##[warning]Public server publishing failed: $($status.publishToPublicServerFailureMessage)"
                }
                
                # Output final status for debugging
                echo ""
                echo "Final Status:"
                $status | ConvertTo-Json
            } else {
                if ($attemptCount -lt $maxAttempts) {
                    echo "  Still processing... waiting 10 seconds before next check"
                    Start-Sleep -Seconds 10
                }
            }
        }
        
        if (-not $publishingComplete) {
            echo "##[warning]Publishing status check timed out after $maxAttempts attempts. Symbols may still be processing."
            echo "You can check status manually at: https://$symbolServer.trafficmanager.net/projects/$projectName/requests/$requestName"
        }
