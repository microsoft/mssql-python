# Linux Single Configuration Stage Template
# Builds Python wheels for a specific Linux distribution and architecture
# Builds for Python 3.10, 3.11, 3.12, 3.13, 3.14 within single job
# Tests each wheel after building with isolated pytest execution
parameters:
  # Stage identifier (e.g., 'Linux_manylinux_x86_64')
  - name: stageName
    type: string
  # Job identifier within the stage
  - name: jobName
    type: string
    default: 'BuildWheels'
  # Linux distribution type: 'manylinux' (glibc-based) or 'musllinux' (musl libc-based)
  - name: linuxTag
    type: string
  # CPU architecture: 'x86_64' (AMD64) or 'aarch64' (ARM64)
  - name: arch
    type: string
  # Docker platform for QEMU emulation: 'linux/amd64' or 'linux/arm64'
  - name: dockerPlatform
    type: string
  # OneBranch build type: 'Official' (production) or 'NonOfficial' (dev/test)
  - name: oneBranchType
    type: string
    default: 'Official'

stages:
  - stage: ${{ parameters.stageName }}
    displayName: 'Linux ${{ parameters.linuxTag }} ${{ parameters.arch }}'
    jobs:
      - job: ${{ parameters.jobName }}
        displayName: 'Build Wheels - ${{ parameters.linuxTag }} ${{ parameters.arch }}'
        
        # Use custom 1ES pool with Ubuntu 22.04 + SQL Server 2022 pre-installed
        pool:
          type: linux
          isCustom: true
          name: Python-1ES-pool
          demands:
          - imageOverride -equals PYTHON-1ES-UB2404
        # Extended timeout for multi-version builds + testing (5 Python versions × build + test time)
        timeoutInMinutes: 120
        
        variables:
          # Disable BinSkim for Linux - requires ICU libraries not available in manylinux/musllinux containers
          - name: ob_sdl_binskim_enabled
            value: false
          # OneBranch output directory for artifacts (wheels, bindings, symbols)
          - name: ob_outputDirectory
            value: '$(Build.ArtifactStagingDirectory)'
          # OneBranch-required variable (unused in this template)
          - name: LinuxContainerImage
            value: 'onebranch.azurecr.io/linux/ubuntu-2204:latest'
          # Distribution type passed to container selection logic
          - name: LINUX_TAG
            value: ${{ parameters.linuxTag }}
          # Architecture passed to container selection and file naming
          - name: ARCH
            value: ${{ parameters.arch }}
          # Docker platform for QEMU-based cross-compilation
          - name: DOCKER_PLATFORM
            value: ${{ parameters.dockerPlatform }}
        
        steps:
          - checkout: self
            fetchDepth: 0
          
          # Docker is pre-installed now
          # Verify it's working and start the daemon
          - bash: |
              set -e
              echo "Verifying we're on Linux..."
              if [[ "$(uname -s)" != "Linux" ]]; then
                echo "ERROR: This job requires a Linux agent but got: $(uname -s)"
                echo "Agent info: $(uname -a)"
                exit 1
              fi
              
              uname -a
              
              # Check if Docker daemon is already running
              if ! docker info > /dev/null 2>&1; then
                echo "Docker daemon not running, starting it..."
                sudo dockerd > docker.log 2>&1 &
                sleep 10
              else
                echo "Docker daemon already running"
              fi
              
              # Verify Docker works
              docker --version
              docker info
            displayName: 'Setup and start Docker daemon'
          
          - script: |
              docker run --rm --privileged tonistiigi/binfmt --install all
            displayName: 'Enable QEMU (for aarch64)'
          
          - script: |
              rm -rf $(ob_outputDirectory)/dist $(ob_outputDirectory)/bindings
              mkdir -p $(ob_outputDirectory)/dist
              mkdir -p $(ob_outputDirectory)/bindings/$(LINUX_TAG)-$(ARCH)
            displayName: 'Prepare artifact directories'
          
          - script: |
              # Determine image based on LINUX_TAG and ARCH
              if [[ "$(LINUX_TAG)" == "musllinux" ]]; then
                IMAGE="quay.io/pypa/musllinux_1_2_$(ARCH)"
              else
                IMAGE="quay.io/pypa/manylinux_2_28_$(ARCH)"
              fi
              
              docker run -d --name build-$(LINUX_TAG)-$(ARCH) \
                --platform $(DOCKER_PLATFORM) \
                -v $(Build.SourcesDirectory):/workspace \
                -w /workspace \
                $IMAGE \
                tail -f /dev/null
            displayName: 'Start $(LINUX_TAG) $(ARCH) container'
          
          - script: |
              set -euxo pipefail
              export PATH=$PATH:`pwd`/docker
              if [[ "$(LINUX_TAG)" == "manylinux" ]]; then
                docker exec build-$(LINUX_TAG)-$(ARCH) bash -lc '
                  set -euxo pipefail
                  if command -v dnf >/dev/null 2>&1; then
                    dnf -y update || true
                    dnf -y install gcc gcc-c++ make cmake unixODBC-devel krb5-libs keyutils-libs ccache || true
                  elif command -v yum >/dev/null 2>&1; then
                    yum -y update || true
                    yum -y install gcc gcc-c++ make cmake unixODBC-devel krb5-libs keyutils-libs ccache || true
                  fi
                  gcc --version || true
                  cmake --version || true
                '
              else
                docker exec build-$(LINUX_TAG)-$(ARCH) sh -lc '
                  set -euxo pipefail
                  apk update || true
                  apk add --no-cache bash build-base cmake unixodbc-dev krb5-libs keyutils-libs ccache || true
                  gcc --version || true
                  cmake --version || true
                '
              fi
            displayName: 'Install system build dependencies'
          
          # Start SQL Server container for pytest execution
          # Runs on host (not in build container) to be accessible from build container via network
          - script: |
              set -euxo pipefail
              
              echo "Starting SQL Server 2022 container for testing..."
              docker run -d --name sqlserver-$(LINUX_TAG)-$(ARCH) \
                --platform linux/amd64 \
                -e ACCEPT_EULA=Y \
                -e MSSQL_SA_PASSWORD="$(DB_PASSWORD)" \
                -p 1433:1433 \
                mcr.microsoft.com/mssql/server:2022-latest
              
              echo "Waiting for SQL Server to be ready..."
              for i in {1..30}; do
                if docker exec sqlserver-$(LINUX_TAG)-$(ARCH) /opt/mssql-tools18/bin/sqlcmd \
                  -S localhost -U SA -P "$(DB_PASSWORD)" -C -Q "SELECT 1" >/dev/null 2>&1; then
                  echo "✓ SQL Server is ready!"
                  break
                fi
                sleep 2
              done
              
              # Get SQL Server container IP for build container to connect
              SQL_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' sqlserver-$(LINUX_TAG)-$(ARCH))
              echo "SQL Server IP: $SQL_IP"
              echo "##vso[task.setvariable variable=SQL_IP]$SQL_IP"
            displayName: 'Start SQL Server container for testing'
            env:
              DB_PASSWORD: $(DB_PASSWORD)
          
          # Build wheels for all Python versions (3.10-3.14) and test each one
          - script: |
              set -euxo pipefail
              if [[ "$(LINUX_TAG)" == "manylinux" ]]; then SHELL_EXE=bash; else SHELL_EXE=sh; fi
              docker exec build-$(LINUX_TAG)-$(ARCH) $SHELL_EXE -lc 'mkdir -p /workspace/dist'
              
              # Loop through all Python versions: build wheel -> test wheel -> repeat
              for PYBIN in cp310 cp311 cp312 cp313 cp314; do
                echo ""
                echo "====================================================="
                echo "Building and testing $PYBIN on $(LINUX_TAG)/$(ARCH)"
                echo "====================================================="
                
                if [[ "$(LINUX_TAG)" == "manylinux" ]]; then
                  # Manylinux (glibc-based) - use bash
                  docker exec -e PYBIN=$PYBIN -e SQL_IP=$(SQL_IP) -e DB_PASSWORD="$(DB_PASSWORD)" build-$(LINUX_TAG)-$(ARCH) bash -lc '
                    set -euxo pipefail;
                    
                    # Step 1: Setup Python environment
                    PY=/opt/python/${PYBIN}-${PYBIN}/bin/python;
                    test -x $PY || { echo "Python $PY missing - skipping"; exit 0; };
                    ln -sf $PY /usr/local/bin/python;
                    echo "Using: $(python --version)";
                    
                    # Step 2: Install build dependencies
                    python -m pip install -q -U pip setuptools wheel pybind11;
                    
                    # Step 3: Build native extension (.so)
                    echo "Building native extension...";
                    cd /workspace/mssql_python/pybind;
                    bash build.sh;
                    
                    # Step 4: Build wheel
                    echo "Building wheel package...";
                    cd /workspace;
                    python setup.py bdist_wheel;
                    
                    # Step 5: Install wheel in isolated directory for testing
                    echo "Installing wheel in isolated test environment...";
                    TEST_DIR="/test_isolated_${PYBIN}";
                    rm -rf $TEST_DIR;
                    mkdir -p $TEST_DIR;
                    cd $TEST_DIR;
                    
                    # Find and install the wheel for this Python version
                    WHEEL=$(ls /workspace/dist/*${PYBIN}*.whl | head -1);
                    if [ -z "$WHEEL" ]; then
                      echo "ERROR: No wheel found for ${PYBIN}";
                      exit 1;
                    fi;
                    echo "Installing: $WHEEL";
                    $PY -m pip install -q "$WHEEL";
                    
                    # Step 6: Verify package imports correctly
                    echo "Verifying package installation...";
                    $PY -c import\ mssql_python;
                    
                    # Step 7: Setup test environment
                    echo "Setting up test environment...";
                    $PY -m pip install -q pytest;
                    cp -r /workspace/tests $TEST_DIR/ || echo "WARNING: No tests directory";
                    cp /workspace/pytest.ini $TEST_DIR/ || echo "WARNING: No pytest.ini";
                    cp /workspace/requirements.txt $TEST_DIR/ || true;
                    $PY -m pip install -q -r $TEST_DIR/requirements.txt || true;
                    
                    # Step 8: Run pytest (stops on first failure)
                    if [ -d $TEST_DIR/tests ]; then
                      echo "Running pytest for ${PYBIN}...";
                      DB_CONNECTION_STRING="Server=$SQL_IP;Database=master;Uid=SA;Pwd=$DB_PASSWORD;TrustServerCertificate=yes" \
                        $PY -m pytest $TEST_DIR/tests -v --maxfail=1 || {
                          echo "ERROR: Tests failed for ${PYBIN}";
                          exit 1;
                        };
                      echo "✓ All tests passed for ${PYBIN}";
                    else
                      echo "WARNING: No tests found, skipping pytest";
                    fi;
                  '
                else
                  # Musllinux (musl libc-based) - use sh
                  docker exec -e PYBIN=$PYBIN -e SQL_IP=$(SQL_IP) -e DB_PASSWORD="$(DB_PASSWORD)" build-$(LINUX_TAG)-$(ARCH) sh -lc '
                    set -euxo pipefail;
                    
                    # Step 1: Setup Python environment
                    PY=/opt/python/${PYBIN}-${PYBIN}/bin/python;
                    test -x $PY || { echo "Python $PY missing - skipping"; exit 0; };
                    ln -sf $PY /usr/local/bin/python;
                    echo "Using: $(python --version)";
                    
                    # Step 2: Install build dependencies
                    python -m pip install -q -U pip setuptools wheel pybind11;
                    
                    # Step 3: Build native extension (.so)
                    echo "Building native extension...";
                    cd /workspace/mssql_python/pybind;
                    bash build.sh;
                    
                    # Step 4: Build wheel
                    echo "Building wheel package...";
                    cd /workspace;
                    python setup.py bdist_wheel;
                    
                    # Step 5: Install wheel in isolated directory for testing
                    echo "Installing wheel in isolated test environment...";
                    TEST_DIR="/test_isolated_${PYBIN}";
                    rm -rf $TEST_DIR;
                    mkdir -p $TEST_DIR;
                    cd $TEST_DIR;
                    
                    # Find and install the wheel for this Python version
                    WHEEL=$(ls /workspace/dist/*${PYBIN}*.whl | head -1);
                    if [ -z "$WHEEL" ]; then
                      echo "ERROR: No wheel found for ${PYBIN}";
                      exit 1;
                    fi;
                    echo "Installing: $WHEEL";
                    $PY -m pip install -q "$WHEEL";
                    
                    # Step 6: Verify package imports correctly
                    echo "Verifying package installation...";
                    $PY -c import\ mssql_python;
                    
                    # Step 7: Setup test environment
                    echo "Setting up test environment...";
                    $PY -m pip install -q pytest;
                    cp -r /workspace/tests $TEST_DIR/ || echo "WARNING: No tests directory";
                    cp /workspace/pytest.ini $TEST_DIR/ || echo "WARNING: No pytest.ini";
                    cp /workspace/requirements.txt $TEST_DIR/ || true;
                    $PY -m pip install -q -r $TEST_DIR/requirements.txt || true;
                    
                    # Step 8: Run pytest (stops on first failure)
                    if [ -d $TEST_DIR/tests ]; then
                      echo "Running pytest for ${PYBIN}...";
                      DB_CONNECTION_STRING="Server=$SQL_IP;Database=master;Uid=SA;Pwd=$DB_PASSWORD;TrustServerCertificate=yes" \
                        $PY -m pytest $TEST_DIR/tests -v --maxfail=1 || {
                          echo "ERROR: Tests failed for ${PYBIN}";
                          exit 1;
                        };
                      echo "✓ All tests passed for ${PYBIN}";
                    else
                      echo "WARNING: No tests found, skipping pytest";
                    fi;
                  '
                fi
                
                echo "✓ Build and test complete for $PYBIN"
              done
              
              echo ""
              echo "====================================================="
              echo "✓ All Python versions built and tested successfully!"
              echo "====================================================="
            displayName: 'Build and test wheels for Python 3.10-3.14'
            env:
              DB_PASSWORD: $(DB_PASSWORD)
          
          # Copy built artifacts from container to host for publishing
          - script: |
              set -euxo pipefail
              
              # Copy all wheels (5 Python versions) to output directory
              echo "Copying wheels to host..."
              docker cp build-$(LINUX_TAG)-$(ARCH):/workspace/dist/. "$(ob_outputDirectory)/wheels/" || echo "No wheels found"
              
              # Copy native .so bindings for artifact archival
              echo "Copying .so bindings to host..."
              mkdir -p "$(ob_outputDirectory)/bindings/$(LINUX_TAG)-$(ARCH)"
              docker exec build-$(LINUX_TAG)-$(ARCH) $([[ "$(LINUX_TAG)" == "manylinux" ]] && echo bash -lc || echo sh -lc) '
                OUT="/tmp/ddbc-out";
                rm -rf "$OUT"; mkdir -p "$OUT";
                find /workspace/mssql_python -maxdepth 1 -type f -name "*.so" -exec cp -v {} "$OUT"/ \; || true
              '
              
              docker cp "build-$(LINUX_TAG)-$(ARCH):/tmp/ddbc-out/." \
                "$(ob_outputDirectory)/bindings/$(LINUX_TAG)-$(ARCH)/" || echo "No .so files found"
              
              echo "✓ Artifacts copied successfully"
            displayName: 'Copy artifacts to host'
          
          # Cleanup: Stop and remove Docker containers
          - script: |
              echo "Stopping and removing containers..."
              docker stop build-$(LINUX_TAG)-$(ARCH) sqlserver-$(LINUX_TAG)-$(ARCH) || true
              docker rm build-$(LINUX_TAG)-$(ARCH) sqlserver-$(LINUX_TAG)-$(ARCH) || true
              echo "✓ Containers cleaned up"
            displayName: 'Cleanup containers'
            condition: always()  # Always run cleanup, even if build/test fails
          
          # Publish artifacts to Azure Pipelines for downstream consumption
          # OneBranch requires specific artifact naming: drop_<stageName>_<jobName>
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Linux Artifacts'
            inputs:
              targetPath: '$(ob_outputDirectory)'
              artifact: 'drop_${{ parameters.stageName }}_${{ parameters.jobName }}'
              publishLocation: 'pipeline'
          
          # Security Scanning: Component Governance + OneBranch AntiMalware
          # Scans wheels and binaries for known vulnerabilities and malware signatures
          - template: ../steps/malware-scanning-step.yml@self
            parameters:
              scanPath: '$(ob_outputDirectory)'
              artifactType: 'dll'
          
          # ESRP Malware Scanning (Official Builds Only)
          # ESRP = Microsoft's Enterprise Signing and Release Platform
          # Scans wheel files for malware using Microsoft Defender and custom signatures
          # Only runs for Official builds (production compliance requirement)
          - ${{ if eq(parameters.oneBranchType, 'Official') }}:
              - task: EsrpMalwareScanning@5
                displayName: 'ESRP MalwareScanning - Python Wheels (Official)'
                inputs:
                  ConnectedServiceName: '$(SigningEsrpConnectedServiceName)'
                  AppRegistrationClientId: '$(SigningAppRegistrationClientId)'
                  AppRegistrationTenantId: '$(SigningAppRegistrationTenantId)'
                  EsrpClientId: '$(SigningEsrpClientId)'
                  UseMSIAuthentication: true
                  FolderPath: '$(ob_outputDirectory)/wheels'
                  Pattern: '*.whl'
                  SessionTimeout: 60
                  CleanupTempStorage: 1
                  VerboseLogin: 1
          
          # ESRP Code Signing (DISABLED - wheel files cannot be signed with SignTool)
          # See compound-esrp-code-signing-step.yml for detailed explanation of why this doesn't work
          # - ${{ if eq(parameters.oneBranchType, 'Official') }}:
          #     - template: /OneBranchPipelines/steps/compound-esrp-code-signing-step.yml@self
          #       parameters:
          #         appRegistrationClientId: '$(SigningAppRegistrationClientId)'
          #         appRegistrationTenantId: '$(SigningAppRegistrationTenantId)'
          #         artifactType: 'whl'
          #         authAkvName: '$(SigningAuthAkvName)'
          #         authSignCertName: '$(SigningAuthSignCertName)'
          #         esrpClientId: '$(SigningEsrpClientId)'
          #         esrpConnectedServiceName: '$(SigningEsrpConnectedServiceName)'
          #         signPath: '$(ob_outputDirectory)/wheels'
