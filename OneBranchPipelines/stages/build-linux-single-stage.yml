# Linux Single Configuration Stage Template
# Builds Python wheels for a specific Linux distribution and architecture
# Builds for Python 3.10, 3.11, 3.12, 3.13 within single job
parameters:
  - name: stageName
    type: string
  - name: jobName
    type: string
    default: 'BuildWheels'
  - name: linuxTag
    type: string  # 'manylinux' or 'musllinux'
  - name: arch
    type: string  # 'x86_64' or 'aarch64'
  - name: dockerPlatform
    type: string  # 'linux/amd64' or 'linux/arm64'
  - name: oneBranchType
    type: string
    default: 'Official'
  - name: signingEnabled
    type: boolean
    default: true
  - name: buildConfiguration
    type: string
    default: 'Release'

stages:
  - stage: ${{ parameters.stageName }}
    displayName: 'Build Linux ${{ parameters.linuxTag }} ${{ parameters.arch }}'
    jobs:
      - job: ${{ parameters.jobName }}
        displayName: 'Build Wheels - ${{ parameters.linuxTag }} ${{ parameters.arch }}'
        pool:
          type: linux
          isCustom: true
          name: Django-1ES-pool
          demands:
          - imageOverride -equals ADO-UB22-SQL22
        timeoutInMinutes: 120
        
        variables:
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
          LinuxContainerImage: 'onebranch.azurecr.io/linux/ubuntu-2204:latest'
          LINUX_TAG: ${{ parameters.linuxTag }}
          ARCH: ${{ parameters.arch }}
          DOCKER_PLATFORM: ${{ parameters.dockerPlatform }}
        
        steps:
          - checkout: self
            fetchDepth: 0
          
          # Install Docker
          - task: DockerInstaller@0
            inputs:
              dockerVersion: '20.10.21'
            displayName: 'Install Docker'
          
          - bash: |
              set -e
              echo "Verifying we're on Linux..."
              if [[ "$(uname -s)" != "Linux" ]]; then
                echo "ERROR: This job requires a Linux agent but got: $(uname -s)"
                echo "Agent info: $(uname -a)"
                exit 1
              fi
              
              uname -a
              
              # Start dockerd
              sudo dockerd > docker.log 2>&1 &
              sleep 10
              
              # Verify Docker works
              docker --version
              docker info
            displayName: 'Setup and start Docker daemon'
          
          - script: |
              docker run --rm --privileged tonistiigi/binfmt --install all
            displayName: 'Enable QEMU (for aarch64)'
          
          - script: |
              rm -rf $(ob_outputDirectory)/dist $(ob_outputDirectory)/bindings
              mkdir -p $(ob_outputDirectory)/dist
              mkdir -p $(ob_outputDirectory)/bindings/$(LINUX_TAG)-$(ARCH)
            displayName: 'Prepare artifact directories'
          
          - script: |
              # Determine image based on LINUX_TAG and ARCH
              if [[ "$(LINUX_TAG)" == "musllinux" ]]; then
                IMAGE="quay.io/pypa/musllinux_1_2_$(ARCH)"
              else
                IMAGE="quay.io/pypa/manylinux_2_28_$(ARCH)"
              fi
              
              docker run -d --name build-$(LINUX_TAG)-$(ARCH) \
                --platform $(DOCKER_PLATFORM) \
                -v $(Build.SourcesDirectory):/workspace \
                -w /workspace \
                $IMAGE \
                tail -f /dev/null
            displayName: 'Start $(LINUX_TAG) $(ARCH) container'
          
          - script: |
              set -euxo pipefail
              export PATH=$PATH:`pwd`/docker
              if [[ "$(LINUX_TAG)" == "manylinux" ]]; then
                docker exec build-$(LINUX_TAG)-$(ARCH) bash -lc '
                  set -euxo pipefail
                  if command -v dnf >/dev/null 2>&1; then
                    dnf -y update || true
                    dnf -y install gcc gcc-c++ make cmake unixODBC-devel krb5-libs keyutils-libs ccache || true
                  elif command -v yum >/dev/null 2>&1; then
                    yum -y update || true
                    yum -y install gcc gcc-c++ make cmake unixODBC-devel krb5-libs keyutils-libs ccache || true
                  fi
                  gcc --version || true
                  cmake --version || true
                '
              else
                docker exec build-$(LINUX_TAG)-$(ARCH) sh -lc '
                  set -euxo pipefail
                  apk update || true
                  apk add --no-cache bash build-base cmake unixodbc-dev krb5-libs keyutils-libs ccache || true
                  gcc --version || true
                  cmake --version || true
                '
              fi
            displayName: 'Install system build dependencies'
          
          - script: |
              set -euxo pipefail
              if [[ "$(LINUX_TAG)" == "manylinux" ]]; then SHELL_EXE=bash; else SHELL_EXE=sh; fi
              docker exec build-$(LINUX_TAG)-$(ARCH) $SHELL_EXE -lc 'mkdir -p /workspace/dist'
              
              for PYBIN in cp310 cp311 cp312 cp313; do
                echo "=== Building for $PYBIN on $(LINUX_TAG)/$(ARCH) ==="
                if [[ "$(LINUX_TAG)" == "manylinux" ]]; then
                  docker exec -e PYBIN=$PYBIN build-$(LINUX_TAG)-$(ARCH) bash -lc '
                    set -euxo pipefail;
                    PY=/opt/python/${PYBIN}-${PYBIN}/bin/python;
                    test -x $PY || { echo "Python $PY missing"; exit 0; };
                    ln -sf $PY /usr/local/bin/python;
                    python -m pip install -U pip setuptools wheel pybind11;
                    cd /workspace/mssql_python/pybind;
                    bash build.sh;
                    cd /workspace;
                    python setup.py bdist_wheel;
                  '
                else
                  docker exec -e PYBIN=$PYBIN build-$(LINUX_TAG)-$(ARCH) sh -lc '
                    set -euxo pipefail;
                    PY=/opt/python/${PYBIN}-${PYBIN}/bin/python;
                    test -x $PY || { echo "Python $PY missing"; exit 0; };
                    ln -sf $PY /usr/local/bin/python;
                    python -m pip install -U pip setuptools wheel pybind11;
                    cd /workspace/mssql_python/pybind;
                    bash build.sh;
                    cd /workspace;
                    python setup.py bdist_wheel;
                  '
                fi
              done
            displayName: 'Build wheels for Python 3.10-3.13'
          
          - script: |
              set -euxo pipefail
              docker cp build-$(LINUX_TAG)-$(ARCH):/workspace/dist/. "$(ob_outputDirectory)/wheels/" || echo "No wheels"
              
              mkdir -p "$(ob_outputDirectory)/bindings/$(LINUX_TAG)-$(ARCH)"
              docker exec build-$(LINUX_TAG)-$(ARCH) $([[ "$(LINUX_TAG)" == "manylinux" ]] && echo bash -lc || echo sh -lc) '
                OUT="/tmp/ddbc-out";
                rm -rf "$OUT"; mkdir -p "$OUT";
                find /workspace/mssql_python -maxdepth 1 -type f -name "*.so" -exec cp -v {} "$OUT"/ \; || true
              '
              
              docker cp "build-$(LINUX_TAG)-$(ARCH):/tmp/ddbc-out/." \
                "$(ob_outputDirectory)/bindings/$(LINUX_TAG)-$(ARCH)/" || echo "No .so files"
            displayName: 'Copy artifacts to host'
          
          - script: |
              docker stop build-$(LINUX_TAG)-$(ARCH) || true
              docker rm build-$(LINUX_TAG)-$(ARCH) || true
            displayName: 'Cleanup container'
            condition: always()
          
          # Explicit publish with OneBranch-compliant artifact name
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Linux Artifacts'
            inputs:
              targetPath: '$(ob_outputDirectory)'
              artifact: 'drop_${{ parameters.stageName }}_${{ parameters.jobName }}'
              publishLocation: 'pipeline'
          
          # General malware scanning (Component Governance + OneBranch AntiMalware)
          - template: ../steps/malware-scanning-step.yml@self
            parameters:
              scanPath: '$(ob_outputDirectory)'
              artifactType: 'dll'
          
          # ESRP Malware scanning (Official builds only)
          - ${{ if and(eq(parameters.signingEnabled, true), eq(parameters.oneBranchType, 'Official')) }}:
              - task: EsrpMalwareScanning@5
                displayName: 'ESRP MalwareScanning - Python Wheels'
                inputs:
                  ConnectedServiceName: '$(SigningEsrpConnectedServiceName)'
                  AppRegistrationClientId: '$(SigningAppRegistrationClientId)'
                  AppRegistrationTenantId: '$(SigningAppRegistrationTenantId)'
                  EsrpClientId: '$(SigningEsrpClientId)'
                  UseMSIAuthentication: true
                  FolderPath: '$(ob_outputDirectory)/wheels'
                  Pattern: '*.whl'
                  CleanupTempStorage: 1
                  VerboseLogin: 1
          
          # ESRP Malware scanning (when signing is enabled)
          - ${{ if eq(parameters.signingEnabled, true) }}:
              - task: EsrpMalwareScanning@5
                displayName: 'ESRP MalwareScanning - Python Wheels'
                inputs:
                  ConnectedServiceName: '$(SigningEsrpConnectedServiceName)'
                  AppRegistrationClientId: '$(SigningAppRegistrationClientId)'
                  AppRegistrationTenantId: '$(SigningAppRegistrationTenantId)'
                  EsrpClientId: '$(SigningEsrpClientId)'
                  UseMSIAuthentication: true
                  FolderPath: '$(ob_outputDirectory)/wheels'
                  Pattern: '*.whl'
                  CleanupTempStorage: 1
                  VerboseLogin: 1
          
          # ESRP Code Signing (when signing is enabled)
          # Note: We only sign wheels on all platforms (Windows, macOS, Linux). The wheel signature cryptographically
          # verifies the entire archive contents, making individual binary signing unnecessary. Additionally,
          # Linux .so files use ELF format which cannot be signed with Windows SignTool.
          #
          # References:
          # - https://eng.ms/docs/products/onebranch/signing/containerbuildsigning#signing-using-onebranchpipelinesigning-ado-task
          #   (specifies not to use raw ESRP task for common certificates)
          # - https://eng.ms/docs/products/onebranch/signing/containerbuildsigning/availablesigningcpcodesandoperations
          #   (key code usage - .whl files not explicitly listed, treated as binary archives)
          - ${{ if eq(parameters.signingEnabled, true) }}:
              - template: /OneBranchPipelines/steps/compound-esrp-code-signing-step.yml@self
                parameters:
                  appRegistrationClientId: '$(SigningAppRegistrationClientId)'
                  appRegistrationTenantId: '$(SigningAppRegistrationTenantId)'
                  artifactType: 'whl'
                  authAkvName: '$(SigningAuthAkvName)'
                  authSignCertName: '$(SigningAuthSignCertName)'
                  esrpClientId: '$(SigningEsrpClientId)'
                  esrpConnectedServiceName: '$(SigningEsrpConnectedServiceName)'
                  signPath: '$(ob_outputDirectory)/wheels'
