# Windows Single Configuration Stage Template
# Builds Python wheel for a specific Python version and architecture
parameters:
  - name: stageName
    type: string
  - name: jobName
    type: string
    default: 'BuildWheel'
  - name: pythonVersion
    type: string
  - name: shortPyVer
    type: string
  - name: architecture
    type: string
  - name: oneBranchType
    type: string
    default: 'Official'
  - name: signingEnabled
    type: boolean
    default: true
  - name: buildConfiguration
    type: string
    default: 'Release'
  - name: publishSymbols
    type: boolean
    default: true

stages:
  - stage: ${{ parameters.stageName }}
    displayName: 'Build Windows Python ${{ parameters.pythonVersion }} ${{ parameters.architecture }}'
    jobs:
      - job: ${{ parameters.jobName }}
        displayName: 'Build Wheel - Python ${{ parameters.pythonVersion }} ${{ parameters.architecture }}'
        pool:
          type: windows
          isCustom: true
          name: Django-1ES-pool
          vmImage: WIN22-SQL22
        timeoutInMinutes: 120
        
        variables:
          ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
          LinuxContainerImage: 'onebranch.azurecr.io/linux/ubuntu-2204:latest'
          pythonVersion: ${{ parameters.pythonVersion }}
          shortPyVer: ${{ parameters.shortPyVer }}
          targetArch: ${{ parameters.architecture }}
          SYSTEM_ACCESSTOKEN: $(System.AccessToken)  # Make System.AccessToken available to all steps in this job
        
        steps:
          - checkout: self
            fetchDepth: 0
          
          - task: UsePythonVersion@0
            inputs:
              versionSpec: '${{ parameters.pythonVersion }}'
              architecture: 'x64'
              addToPath: true
            displayName: 'Use Python ${{ parameters.pythonVersion }} (${{ parameters.architecture }})'
            continueOnError: false
          
          - powershell: |
              Write-Host "Python version:"
              python --version
              Write-Host "Python location:"
              python -c "import sys; print(sys.executable)"
              Write-Host "Architecture:"
              python -c "import platform; print(platform.machine())"
            displayName: 'Verify Python installation'
          
          - powershell: |
              $ErrorActionPreference = "Stop"
              Write-Host "Installing Python dependencies..."
              python -m pip install --upgrade pip
              python -m pip install setuptools wheel pybind11 pytest pyodbc
              Write-Host "Dependencies installed successfully"
            displayName: 'Install Python dependencies'
          
          - powershell: |
              sqllocaldb create MSSQLLocalDB
              sqllocaldb start MSSQLLocalDB
            displayName: 'Start LocalDB instance'
          
          - powershell: |
              sqlcmd -S "(localdb)\MSSQLLocalDB" -Q "CREATE DATABASE TestDB"
              sqlcmd -S "(localdb)\MSSQLLocalDB" -Q "CREATE LOGIN testuser WITH PASSWORD = '$(DB_PASSWORD)'"
              sqlcmd -S "(localdb)\MSSQLLocalDB" -d TestDB -Q "CREATE USER testuser FOR LOGIN testuser"
              sqlcmd -S "(localdb)\MSSQLLocalDB" -d TestDB -Q "ALTER ROLE db_owner ADD MEMBER testuser"
            displayName: 'Setup database and user'
            env:
              DB_PASSWORD: $(DB_PASSWORD)
          
          - powershell: |
              # Download Python ARM64 from NuGet (contains libs directory with python.lib)
              $pythonVer = "${{ parameters.pythonVersion }}"
              
              # Map version to NuGet package version
              $nugetVersion = switch ($pythonVer) {
                "3.10" { "3.10.11" }
                "3.11" { "3.11.9" }
                "3.12" { "3.12.7" }
                "3.13" { "3.13.0" }
                "3.14" { "3.14.0-a2" }
                default { throw "Unsupported Python version: $pythonVer" }
              }
              
              $nugetUrl = "https://www.nuget.org/api/v2/package/pythonarm64/$nugetVersion"
              $nugetFile = "$(Build.SourcesDirectory)\pythonarm64.nupkg"
              $zipFile = "$(Build.SourcesDirectory)\pythonarm64.zip"
              $extractPath = "$(Build.SourcesDirectory)\pythonarm64-nuget"
              $destPath = "$(Build.SourcesDirectory)\mssql_python\pybind\python_libs\arm64"
              
              Write-Host "Downloading Python $pythonVer ARM64 NuGet package from: $nugetUrl"
              Invoke-WebRequest -Uri $nugetUrl -OutFile $nugetFile -UseBasicParsing
              
              Write-Host "Renaming .nupkg to .zip for extraction..."
              Move-Item -Path $nugetFile -Destination $zipFile -Force
              
              Write-Host "Extracting NuGet package..."
              Expand-Archive -Path $zipFile -DestinationPath $extractPath -Force
              
              Write-Host "`nSearching for libs directory..."
              $libsDir = Get-ChildItem -Path $extractPath -Recurse -Directory -Filter "libs" | Select-Object -First 1
              
              if ($libsDir) {
                Write-Host "Found libs at: $($libsDir.FullName)"
                New-Item -ItemType Directory -Force -Path $destPath | Out-Null
                Copy-Item -Path "$($libsDir.FullName)\*" -Destination $destPath -Recurse -Force
                Write-Host "✓ Copied .lib files from NuGet package"
              } else {
                Write-Host "libs directory not found, searching for .lib files..."
                $libFiles = Get-ChildItem -Path $extractPath -Recurse -Filter "*.lib"
                New-Item -ItemType Directory -Force -Path $destPath | Out-Null
                foreach ($lib in $libFiles) {
                  Write-Host "  Copying $($lib.Name)"
                  Copy-Item -Path $lib.FullName -Destination $destPath -Force
                }
              }
              
              Write-Host "`nContents of $destPath :"
              Get-ChildItem $destPath | ForEach-Object { Write-Host "  - $($_.Name)" }
              
              $expectedLib = "python$($pythonVer.Replace('.', '')).lib"
              if (Test-Path "$destPath\$expectedLib") {
                Write-Host "`n✓ $expectedLib found"
              } else {
                Write-Error "$expectedLib not found in NuGet package!"
                exit 1
              }
              
              # Cleanup
              Remove-Item -Path $zipFile -Force -ErrorAction SilentlyContinue
              Remove-Item -Path $extractPath -Recurse -Force -ErrorAction SilentlyContinue
            condition: eq(variables['targetArch'], 'arm64')
            displayName: 'Download Python ARM64 libs from NuGet'
          
          - script: |
              echo "Python Version: $(pythonVersion)"
              echo "Short Tag: $(shortPyVer)"
              echo "Architecture: Host=$(architecture), Target=$(targetArch)"
              
              cd "$(Build.SourcesDirectory)\mssql_python\pybind"
              
              REM Override lib path for ARM64
              if "$(targetArch)"=="arm64" (
                echo Using arm64-specific Python library...
                set CUSTOM_PYTHON_LIB_DIR=$(Build.SourcesDirectory)\mssql_python\pybind\python_libs\arm64
              )
              
              call build.bat $(targetArch)
              call keep_single_arch.bat $(targetArch)
              
              cd ..\..
            displayName: 'Build PYD for $(targetArch)'
            continueOnError: false
          
          - powershell: |
              Write-Host "Running pytests to validate bindings"
              if ("$(targetArch)" -eq "arm64") {
                Write-Host "Skipping pytests on Windows ARM64"
              } else {
                python -m pytest -v
              }
            displayName: 'Run pytests'
            env:
              DB_CONNECTION_STRING: 'Server=(localdb)\MSSQLLocalDB;Database=TestDB;Uid=testuser;Pwd=$(DB_PASSWORD);TrustServerCertificate=yes'
          
          - task: CopyFiles@2
            inputs:
              SourceFolder: '$(Build.SourcesDirectory)\mssql_python\pybind\build\$(targetArch)\py$(shortPyVer)\Release'
              Contents: 'ddbc_bindings.cp$(shortPyVer)-*.pyd'
              TargetFolder: '$(ob_outputDirectory)\bindings\windows'
            displayName: 'Copy PYD files'
          
          - task: CopyFiles@2
            inputs:
              SourceFolder: '$(Build.SourcesDirectory)\mssql_python\pybind\build\$(targetArch)\py$(shortPyVer)\Release'
              Contents: 'ddbc_bindings.cp$(shortPyVer)-*.pdb'
              TargetFolder: '$(ob_outputDirectory)\symbols'
            displayName: 'Copy PDB files'
          
          # Copy files to ApiScan directories (for globalSdl scanning)
          - task: CopyFiles@2
            inputs:
              SourceFolder: '$(Build.SourcesDirectory)\mssql_python\pybind\build\$(targetArch)\py$(shortPyVer)\Release'
              Contents: 'ddbc_bindings.cp$(shortPyVer)-*.pyd'
              TargetFolder: '$(Build.SourcesDirectory)\apiScan\dlls\windows\py$(shortPyVer)\$(targetArch)'
            displayName: 'Copy PYD to ApiScan directory'
          
          - task: CopyFiles@2
            inputs:
              SourceFolder: '$(Build.SourcesDirectory)\mssql_python\pybind\build\$(targetArch)\py$(shortPyVer)\Release'
              Contents: 'ddbc_bindings.cp$(shortPyVer)-*.pdb'
              TargetFolder: '$(Build.SourcesDirectory)\apiScan\pdbs\windows\py$(shortPyVer)\$(targetArch)'
            displayName: 'Copy PDB to ApiScan directory'

          
          - script: |
              python -m pip install --upgrade pip wheel setuptools
              set ARCHITECTURE=$(targetArch)
              python setup.py bdist_wheel
            displayName: 'Build wheel package'
          
          - task: CopyFiles@2
            inputs:
              SourceFolder: '$(Build.SourcesDirectory)\dist'
              Contents: '*.whl'
              TargetFolder: '$(ob_outputDirectory)\wheels'
            displayName: 'Copy wheel files'
          
          # Explicit publish with OneBranch-compliant artifact name
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Windows Artifacts'
            inputs:
              targetPath: '$(ob_outputDirectory)'
              artifact: 'drop_${{ parameters.stageName }}_${{ parameters.jobName }}'
              publishLocation: 'pipeline'
          
          # General malware scanning (Component Governance + OneBranch AntiMalware)
          - template: /OneBranchPipelines/steps/malware-scanning-step.yml@self
            parameters:
              scanPath: '$(ob_outputDirectory)'
              artifactType: 'dll'
          
          # ESRP Malware scanning (when signing is enabled)
          - ${{ if eq(parameters.signingEnabled, true) }}:
              - task: EsrpMalwareScanning@5
                displayName: 'ESRP MalwareScanning - Python Wheels'
                inputs:
                  ConnectedServiceName: '$(SigningEsrpConnectedServiceName)'
                  AppRegistrationClientId: '$(SigningAppRegistrationClientId)'
                  AppRegistrationTenantId: '$(SigningAppRegistrationTenantId)'
                  EsrpClientId: '$(SigningEsrpClientId)'
                  UseMSIAuthentication: true
                  FolderPath: '$(ob_outputDirectory)/wheels'
                  Pattern: '*.whl'
                  SessionTimeout: 60
                  CleanupTempStorage: 1
                  VerboseLogin: 1
          
          # ESRP Code Signing (DISABLED - wheel files cannot be signed with SignTool)
          # See compound-esrp-code-signing-step.yml for detailed explanation of why this doesn't work
          # - ${{ if eq(parameters.signingEnabled, true) }}:
          #     - template: /OneBranchPipelines/steps/compound-esrp-code-signing-step.yml@self
          #       parameters:
          #         appRegistrationClientId: '$(SigningAppRegistrationClientId)'
          #         appRegistrationTenantId: '$(SigningAppRegistrationTenantId)'
          #         artifactType: 'whl'
          #         authAkvName: '$(SigningAuthAkvName)'
          #         authSignCertName: '$(SigningAuthSignCertName)'
          #         esrpClientId: '$(SigningEsrpClientId)'
          #         esrpConnectedServiceName: '$(SigningEsrpConnectedServiceName)'
          #         signPath: '$(ob_outputDirectory)\wheels'
          
          # Note: Symbol publishing moved to release pipeline
          # Symbols are published as artifacts here and consumed in release pipeline
