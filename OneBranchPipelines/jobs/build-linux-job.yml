# Linux Build Job Template
# Builds Python wheels and native bindings for Linux (manylinux and musllinux)
parameters:
  - name: oneBranchType
    type: string
    default: 'Official'
  
  - name: signingEnabled
    type: boolean
    default: true
  
  - name: buildConfiguration
    type: string
    default: 'Release'

jobs:
  - job: BuildLinuxWheels
    displayName: 'Build Linux Wheels'
    pool:
      type: linux
    timeoutInMinutes: 120
    
    strategy:
      matrix:
        manylinux_x86_64:
          LINUX_TAG: 'manylinux'
          ARCH: 'x86_64'
          DOCKER_PLATFORM: 'linux/amd64'
          IMAGE: 'quay.io/pypa/manylinux_2_28_x86_64'
        manylinux_aarch64:
          LINUX_TAG: 'manylinux'
          ARCH: 'aarch64'
          DOCKER_PLATFORM: 'linux/arm64'
          IMAGE: 'quay.io/pypa/manylinux_2_28_aarch64'
        musllinux_x86_64:
          LINUX_TAG: 'musllinux'
          ARCH: 'x86_64'
          DOCKER_PLATFORM: 'linux/amd64'
          IMAGE: 'quay.io/pypa/musllinux_1_2_x86_64'
        musllinux_aarch64:
          LINUX_TAG: 'musllinux'
          ARCH: 'aarch64'
          DOCKER_PLATFORM: 'linux/arm64'
          IMAGE: 'quay.io/pypa/musllinux_1_2_aarch64'
    
    variables:
      ob_outputDirectory: '$(Build.ArtifactStagingDirectory)'
      # OneBranch requires a container image - using standard Linux container
      LinuxContainerImage: 'onebranch.azurecr.io/linux/ubuntu-2204:latest'
    
    steps:
      - checkout: self
        fetchDepth: 0
      
      - script: |
          curl -fsSL https://get.docker.com -o get-docker.sh
          sudo sh get-docker.sh
          sudo systemctl start docker
          sudo usermod -aG docker $USER
        displayName: 'Install Docker'
      
      - script: |
          sudo docker run --rm --privileged tonistiigi/binfmt --install all
        displayName: 'Enable QEMU (for aarch64)'
      
      - script: |
          rm -rf $(ob_outputDirectory)/dist $(ob_outputDirectory)/bindings
          mkdir -p $(ob_outputDirectory)/dist
          mkdir -p $(ob_outputDirectory)/bindings/$(LINUX_TAG)-$(ARCH)
        displayName: 'Prepare artifact directories'
      
      - script: |
          docker run -d --name build-$(LINUX_TAG)-$(ARCH) \
            --platform $(DOCKER_PLATFORM) \
            -v $(Build.SourcesDirectory):/workspace \
            -w /workspace \
            $(IMAGE) \
            tail -f /dev/null
        displayName: 'Start $(LINUX_TAG) $(ARCH) container'
      
      - script: |
          set -euxo pipefail
          if [[ "$(LINUX_TAG)" == "manylinux" ]]; then
            docker exec build-$(LINUX_TAG)-$(ARCH) bash -lc '
              set -euxo pipefail
              if command -v dnf >/dev/null 2>&1; then
                dnf -y update || true
                dnf -y install gcc gcc-c++ make cmake unixODBC-devel krb5-libs keyutils-libs ccache || true
              elif command -v yum >/dev/null 2>&1; then
                yum -y update || true
                yum -y install gcc gcc-c++ make cmake unixODBC-devel krb5-libs keyutils-libs ccache || true
              fi
              gcc --version || true
              cmake --version || true
            '
          else
            docker exec build-$(LINUX_TAG)-$(ARCH) sh -lc '
              set -euxo pipefail
              apk update || true
              apk add --no-cache bash build-base cmake unixodbc-dev krb5-libs keyutils-libs ccache || true
              gcc --version || true
              cmake --version || true
            '
          fi
        displayName: 'Install system build dependencies'
      
      - script: |
          set -euxo pipefail
          if [[ "$(LINUX_TAG)" == "manylinux" ]]; then SHELL_EXE=bash; else SHELL_EXE=sh; fi
          docker exec build-$(LINUX_TAG)-$(ARCH) $SHELL_EXE -lc 'mkdir -p /workspace/dist'
          
          for PYBIN in cp310 cp311 cp312 cp313; do
            echo "=== Building for $PYBIN on $(LINUX_TAG)/$(ARCH) ==="
            if [[ "$(LINUX_TAG)" == "manylinux" ]]; then
              docker exec build-$(LINUX_TAG)-$(ARCH) bash -lc "
                set -euxo pipefail;
                PY=/opt/python/\${PYBIN}-\${PYBIN}/bin/python;
                test -x \$PY || { echo 'Python \$PY missing'; exit 0; };
                ln -sf \$PY /usr/local/bin/python;
                python -m pip install --trusted-host pypi.org --trusted-host files.pythonhosted.org -U pip setuptools wheel pybind11 || python -m pip install -U pip setuptools wheel pybind11;
                cd /workspace/mssql_python/pybind;
                bash build.sh;
                cd /workspace;
                python setup.py bdist_wheel;
              "
            else
              docker exec build-$(LINUX_TAG)-$(ARCH) sh -lc "
                set -euxo pipefail;
                PY=/opt/python/\${PYBIN}-\${PYBIN}/bin/python;
                test -x \$PY || { echo 'Python \$PY missing'; exit 0; };
                ln -sf \$PY /usr/local/bin/python;
                python -m pip install --trusted-host pypi.org --trusted-host files.pythonhosted.org -U pip setuptools wheel pybind11 || python -m pip install -U pip setuptools wheel pybind11;
                cd /workspace/mssql_python/pybind;
                bash build.sh;
                cd /workspace;
                python setup.py bdist_wheel;
              "
            fi
          done
        displayName: 'Build wheels for Python 3.10-3.13'
      
      - script: |
          set -euxo pipefail
          docker cp build-$(LINUX_TAG)-$(ARCH):/workspace/dist/. "$(ob_outputDirectory)/wheels/" || echo "No wheels"
          
          mkdir -p "$(ob_outputDirectory)/bindings/$(LINUX_TAG)-$(ARCH)"
          docker exec build-$(LINUX_TAG)-$(ARCH) $([[ "$(LINUX_TAG)" == "manylinux" ]] && echo bash -lc || echo sh -lc) '
            OUT="/tmp/ddbc-out";
            rm -rf "$OUT"; mkdir -p "$OUT";
            find /workspace/mssql_python -maxdepth 1 -type f -name "*.so" -exec cp -v {} "$OUT"/ \; || true
          '
          
          docker cp "build-$(LINUX_TAG)-$(ARCH):/tmp/ddbc-out/." \
            "$(ob_outputDirectory)/bindings/$(LINUX_TAG)-$(ARCH)/" || echo "No .so files"
        displayName: 'Copy artifacts to host'
      
      - script: |
          docker stop build-$(LINUX_TAG)-$(ARCH) || true
          docker rm build-$(LINUX_TAG)-$(ARCH) || true
        displayName: 'Cleanup container'
        condition: always()
      
      # Malware scanning
      - template: ../steps/malware-scanning-step.yml@self
        parameters:
          scanPath: '$(ob_outputDirectory)'
          artifactType: 'dll'
      
      # ESRP Code Signing (Official builds only)
      - ${{ if and(eq(parameters.signingEnabled, true), eq(parameters.oneBranchType, 'Official')) }}:
          - template: /OneBranchPipelines/steps/compound-esrp-code-signing-step.yml@self
            parameters:
              appRegistrationClientId: '$(SigningAppRegistrationClientId)'
              appRegistrationTenantId: '$(SigningAppRegistrationTenantId)'
              artifactType: 'dll'
              authAkvName: '$(SigningAuthAkvName)'
              authSignCertName: '$(SigningAuthSignCertName)'
              esrpClientId: '$(SigningEsrpClientId)'
              esrpConnectedServiceName: '$(SigningEsrpConnectedServiceName)'
              signPath: '$(ob_outputDirectory)/bindings'
          
          - template: /OneBranchPipelines/steps/compound-esrp-code-signing-step.yml@self
            parameters:
              appRegistrationClientId: '$(SigningAppRegistrationClientId)'
              appRegistrationTenantId: '$(SigningAppRegistrationTenantId)'
              artifactType: 'whl'
              authAkvName: '$(SigningAuthAkvName)'
              authSignCertName: '$(SigningAuthSignCertName)'
              esrpClientId: '$(SigningEsrpClientId)'
              esrpConnectedServiceName: '$(SigningEsrpConnectedServiceName)'
              signPath: '$(ob_outputDirectory)/wheels'
